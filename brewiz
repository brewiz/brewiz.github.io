#!/usr/bin/env ruby

require 'json'
require 'open-uri'
require 'open3'
require 'webrick'
require 'yaml'
require 'optparse'

def bun_installed?
  system('which bun > /dev/null 2>&1')
end

def start_dev_server(options)
  command = bun_installed? ? "bun dev --port #{options[:dev_port]}" : "npm run dev --port #{options[:dev_port]}"
  puts "Starting dev server with: #{command}"

  pid = Process.spawn(command, chdir: File.expand_path('..', __FILE__))
  at_exit { Process.kill('TERM', pid) rescue nil }

  sleep(1) until dev_server_running?(options)
end

def dev_server_running?(options)
  puts "Checking if Dev Server is running on http://#{options[:address]}:#{options[:dev_port]}"
  Net::HTTP.get_response(URI("http://#{options[:address]}:#{options[:dev_port]}")).is_a?(Net::HTTPSuccess)
rescue StandardError
  puts "Dev server not running"
  false
end

def parse_options
  options = {
    dev_mode: false,
    port: 8047,
    address: 'localhost',
    dev_port: 8048,
    packages_url: 'https://gist.githubusercontent.com/wstein/e0b807d6facb73bf150d916d23493b61/raw/73c3d89de56d6ae83e7f835f42b845e2abcc27ef/packages.yaml',
    packages_file: nil
  }

  OptionParser.new do |opts|
    opts.banner = "Usage: brewiz [options]"

    opts.on("-d", "--dev", "Enable development mode") do
      options[:dev_mode] = true
    end

    opts.on("-a", "--address ADDRESS", "Address to run Server on (default: localhost)") do |address|
      options[:address] = address
    end

    opts.on("-p", "--port PORT", Integer, "Port to run Server on (default: 8047)") do |port|
      options[:port] = port
    end

    opts.on("--dev-port PORT", Integer, "Frontend Vite Dev Server port (default: 8048)") do |port|
      options[:dev_port] = port
    end

    opts.on("--packages-url URL", "URL to packages configuration YAML") do |url|
      options[:packages_url] = url
      options[:packages_file] = nil  # URL takes precedence over file
    end

    opts.on("--packages-file PATH", "Path to local packages configuration YAML file") do |path|
      options[:packages_file] = path
      options[:packages_url] = nil  # Clear URL if file is specified
    end

    opts.on("-h", "--help", "Show this help message") do
      puts opts
      exit
    end
  end.parse!

  options
end

def main
  options = parse_options

  # Initialize application components
  homebrew = Homebrew.new
  package_manager = PackageManager.new(homebrew, options)  # Pass options to PackageManager

  # Start dev server if in dev mode
  start_dev_server(options) if options[:dev_mode]

  # Configure and start WEBrick server
  server = WEBrick::HTTPServer.new(
    Port: options[:port],
    BindAddress: options[:address],
    Logger: WEBrick::Log.new($stderr, WEBrick::Log::INFO)
  )

  # Mount the handler
  server.mount('/', BrewizHandler, homebrew, package_manager, options)

  # Handle graceful shutdown on SIGINT (Ctrl+C)
  trap('INT') { server.shutdown }

  # Open the browser
  Thread.new do
     require 'net/http'
     until Net::HTTP.get_response(URI("http://#{options[:address]}:#{options[:port]}")).is_a?(Net::HTTPSuccess)
       sleep(0.1)
     end
     puts "Opening browser..."
     system('open', "http://#{options[:address]}:#{options[:port]}")
  end

  # Start the server
  puts "Starting Brewiz server on http://#{options[:address]}:#{options[:port]}"
  server.start
end

# The Homebrew class implements the brew command line tool
class Homebrew
  def initialize
    @brew = '/opt/homebrew/bin/brew'
  end

  def brew_info
    stdout, stderr, status = Open3.capture3(@brew, 'info', '--installed', '--json=v2')
    raise "Failed to get brew info: #{stderr}" unless status.success?
    JSON.parse(stdout)
  end

  def brew_update
    stdout, stderr, status = Open3.capture3(@brew, 'update')
    raise stderr unless status.success?
    stdout
  end

  def info
    bi = brew_info
    process_info(bi['formulae'], :formula) +
    process_info(bi['casks'], :cask)
  end

  private

  def process_info(packages, type)
    packages.map do |pkg|
      create_package_info(pkg, type == :cask)
    end
  end

  def create_package_info(pkg, cask)
    name = cask ? pkg['name'][0] : pkg['name']
    token = cask ? pkg['token'] : name
    {
      name: name,
      id: "#{pkg['tap']}/#{token}",
      description: pkg['desc'],
      homepage: pkg['homepage'],
      pinned: pkg['pinned'] || false,
      installed: true,
      installed_on_request: cask || pkg['installed'].any? { |i| i['installed_on_request'] },
      outdated: pkg['outdated'],
      deprecated: pkg['deprecated'],
      cask: cask
    }.transform_keys(&:to_s)
  end
end

# PackageManager class to handle package categorization and management
class PackageManager
  attr_reader :packages

  def initialize(homebrew, options)
    @homebrew = homebrew
    @options = options
    load_packages
  end

  def reload
    load_packages
    @packages
  end

  private

  def load_packages
    puts "Updating Homebrew..."
    res = @homebrew.brew_update
    puts res if res

    puts "Getting local Packages..."
    brew_info = @homebrew.info.to_h { |pkg| [pkg['id'], pkg] }

    # Load package categories from URL or file
    @packages = load_packages_config

    merge_brew_info_with_categories(brew_info)
    add_uncategorized_packages(brew_info)
    sort_categories_with_unknown_last

    @packages
  end

  def load_packages_config
    if @options[:packages_file]
      begin
        YAML.load_file(@options[:packages_file])
      rescue => e
        puts "Error loading packages file: #{e.message}"
        puts "Falling back to default URL"
        load_packages_from_url(@options[:packages_url])
      end
    else
      load_packages_from_url(@options[:packages_url])
    end
  end

  def load_packages_from_url(url)
    begin
      YAML.safe_load(URI.open(url).read)
    rescue => e
      puts "Error loading packages from URL: #{e.message}"
      puts "Using empty configuration"
      [{ 'id' => 'unknown', 'name' => 'Unknown', 'packages' => [] }]
    end
  end

  def merge_brew_info_with_categories(brew_info)
    @packages.each do |category|
      category['packages'].map! do |pkg|
        id = pkg['id']
        info = brew_info[id]
        if info
          pkg.merge!(brew_info.delete(id))
        end
        pkg
      end
    end
  end

  def add_uncategorized_packages(brew_info)
    @packages.map! do |category|
      if category['id'] == 'unknown'
      category['packages'] += brew_info.values.select { |pkg| pkg['installed_on_request'] }
      end
      category
    end
  end

  def sort_categories_with_unknown_last
    @packages.sort_by! { |category| [category['id'] == 'unknown' ? 1 : 0, category['id']] }
  end
end

# API handler for WEBrick
class BrewizHandler < WEBrick::HTTPServlet::AbstractServlet
  def initialize(server, homebrew, package_manager, options)
    super(server)
    @homebrew = homebrew
    @package_manager = package_manager
    @options = options
  end

  def do_GET(request, response)
    case request.path
    when '/api/v1/packages'
      response['Content-Type'] = 'application/json'
      response.body = @package_manager.packages.to_json
    when '/api/v1/reload'
      puts "Reloading packages..."
      response['Content-Type'] = 'application/json'
      response.body = @package_manager.reload.to_json
    else
      if @options[:dev_mode] && !request.path.start_with?('/api/')
        proxy_request(request, response)
      else
        serve_static_content(request, response)
      end
    end
  end

  private

  def proxy_request(request, response)
    case request.path
    when '/homebrew.svg'
      response['Content-Type'] = 'image/svg+xml'
      response.body = HOMEBREW_SVG
    else
      uri = URI("http://#{@options[:address]}:#{@options[:dev_port]}#{request.path}")
      begin
        proxy_response = Net::HTTP.get_response(uri)
        response.status = proxy_response.code
        proxy_response.each_header do |k, v|
          response[k] = v
        end
        response.body = proxy_response.body
      rescue StandardError => e
        response.status = 502
        response.body = { error: "Dev server not responding: #{e.message}" }.to_json
      end
    end
  end

  def serve_static_content(request, response)
    case request.path
    when '/homebrew.svg'
      response['Content-Type'] = 'image/svg+xml'
      response.body = HOMEBREW_SVG
    when '/assets/index.js'
      response['Content-Type'] = 'application/javascript'
      response.body = ASSETS_INDEX_JS
    when '/assets/index.css'
      response['Content-Type'] = 'text/css'
      response.body = ASSETS_INDEX_CSS
    when '/'
      response['Content-Type'] = 'text/html'
      response.body = INDEX_HTML
    else
      response.status = 404
      response.body = { error: 'Not Found' }.to_json
    end
  end
end

# START STATIC FILE CONTENT
HOMEBREW_SVG = URI.open('https://upload.wikimedia.org/wikipedia/commons/9/95/Homebrew_logo.svg').read
INDEX_HTML = URI.open('https://raw.githubusercontent.com/wstein/brewiz/refs/heads/main/dist/index.html').read
ASSETS_INDEX_CSS = URI.open('https://raw.githubusercontent.com/wstein/brewiz/refs/heads/main/dist/assets/index.css').read
ASSETS_INDEX_JS = URI.open('https://raw.githubusercontent.com/wstein/brewiz/refs/heads/main/dist/assets/index.js').read

main if __FILE__ == $PROGRAM_NAME
